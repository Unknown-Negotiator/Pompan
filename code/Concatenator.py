#!/usr/bin/env python

import fastaparser
import os
import argparse

def fasta_reader(fasta_file):
    """
    Args:
        fasta_file: path to a file in fasta format
    Returns:
        dictionary with key == fasta header, value == sequence
    """
    with open(fasta_file) as fh:
        parser = fastaparser.Reader(fh, parse_method='quick')
        seq_dict = {}
        for seq in parser:
            seq_dict[seq.header] = seq.sequence
    return seq_dict

def make_dic_list(input_files_directory):
    '''
    Args:
        input_files_directory: path to the directory with input fasta files
    Returns:
        list of dictionaries with key == fasta header, value == sequence. Each dictionary represents all sequences within one input file.
    '''
    pathes = os.listdir(input_files_directory)
    pathes.sort()
    list = []
    for path in pathes:
      list.append(fasta_reader(input_files_directory + '/' + path))
    return list

def fix_headers(fasta_dics_list):
    '''
    Args:
        fasta_dics_list: list of dictionaries with key == fasta header, generated automatically by prokka; value == sequence.
    Returns:
        list of dictionaries with key == first 8 characters of fasta header, generated automatically by prokka; value == sequence.
        First 8 characters of a header allow us to identify all sequences related to the particular organism.
    '''
    new_list = []
    for dic in fasta_dics_list:
      new_dic = {}
      for key in dic.keys():
        new_dic[key[0:9]] = dic[key]
      new_list.append(new_dic)
    return new_list

def bigest_dic(fasta_dics_list):
    '''
    Args:
        fasta_dics_list: list of dictionaries with key == fasta header; value == sequence.
    Returns:
        dictionary with maximum length
    '''
    maxDicLen = len(fasta_dics_list[0])
    maxDic = fasta_dics_list[0]
    for dic in fasta_dics_list:
      if maxDicLen < len(dic):
        maxDicLen  = len(dic)
        maxDic = dic
    return maxDic

def concatenator(fasta_dics_list):
    '''
    Args:
        fasta_dics_list: list of dictionaries with key == fasta header; value == sequence.
    Returns:
        dictionary with key == fasta header; value == sequences from each dictionary in the input list, concatenated by header
    '''
    maxDic = bigest_dic(fasta_dics_list)
    new_dic = {}
    for id in maxDic.keys():
      new_dic[id] = maxDic[id]
      first = True
      for dic in fasta_dics_list:
        if not first:
          new_dic[id] += str(dic.get(id))
        first = False
    return new_dic

def fasta_writer(fasta_dict, output_path):
    """
    Args:
        fasta_dict: dictionary with key == fasta header; value == concatenated sequences
        output_path: path to the file for output
    Returns:
        writes concatenated sequences to the output file in fasta format
    """
    file = output_path
    with open(file, "w") as fh:
      for key, value in fasta_dict.items():
        fh.write(key + '\n' + value + '\n')

def str2bool(v):
    if isinstance(v, bool):
        return v
    if v.lower() in ('yes', 'true', 't', 'y', '1'):
        return True
    elif v.lower() in ('no', 'false', 'f', 'n', '0'):
        return False
    else:
        raise argparse.ArgumentTypeError('Boolean value expected.')

def run(args):
    dics_list = make_dic_list(args.input)
    if args.fix_headers:
      dics_list = fix_headers(dics_list)
    fasta_writer(concatenator(dics_list), args.output)

def main():
    parser=argparse.ArgumentParser(description="Concatenate fasta files from directory based on headers")
    parser.add_argument("-i",help="path to the directory with input fasta files", dest="input", type=str, required=True)
    parser.add_argument("-o",help="path to the output fasta file", dest="output", type=str, required=True)
    parser.add_argument("-f", dest="fix_headers",type=str2bool, nargs='?', const=True, default=False,
                        help="A boolean stating whether headers in input files should be fixed: only first 8 characters of headers will be used."
                                  "This option is recommended when working with Protein FASTA files generated by prokka")
    parser.set_defaults(func=run)
    args=parser.parse_args()
    args.func(args)

if __name__=="__main__":
	main()